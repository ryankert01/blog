[{"content":"With carefulness, leverage ETFs boosts returns Leveraged ETFs can amplify investment returns when used strategically. While higher leverage ratios (2x or 3x) can be risky, a modest 1.25x leverage offers a balanced approach to enhance returns while managing risk.\nETFs choice For our analysis, we selected two major market-tracking ETFs that offer broad market exposure and high liquidity. The combination of S\u0026amp;P 500 (VOO) and NASDAQ 100 (QQQ) provides diversification across both traditional blue-chip stocks and technology-focused growth companies.\nLeverage boost performance Our analysis compares a base portfolio of VOO (50%) and QQQ (50%) with a 1.25x leveraged version, assuming a 3% borrowing cost. The results reveal interesting insights about the risk-return tradeoff of modest leverage:\nReturns Enhancement Total return increased significantly from 344.20% to 463.81% Annual return improved from 15.98% to 18.76%, representing a 17.8% increase The power of leverage is evident in the cumulative returns chart, showing consistent outperformance Risk Considerations Annual volatility rose proportionally from 19.43% to 24.29% Maximum drawdown deepened from -31.00% to -37.79% Market sensitivity (Beta) increased from 1.07 to 1.33 Risk metrics (VaR 95% and CVaR 95%) showed moderately higher downside risk Risk-Adjusted Performance Sharpe Ratio remained virtually unchanged (0.7066 vs 0.7061) Sortino Ratio showed slight improvement (0.876 vs 0.875) Information Ratio decreased from 3.07 to 2.02 Calmar Ratio experienced minimal decline (0.515 to 0.496) Finding Appropriate Leverage Methods Selecting the right leverage method is crucial for portfolio management. Here are the main approaches to obtaining leverage:\nMargin Accounts\nUse your existing portfolio as collateral Typically offers competitive interest rates Provides flexibility in leverage amount Subject to margin calls during market downturns Securities-Based Lines of Credit (SBLOC)\nUses your investment portfolio as collateral Often offers lower interest rates than margin accounts No set repayment schedule More stable than margin accounts during market volatility Home Equity Lines of Credit (HELOC)\nUses home equity as collateral Generally offers lower interest rates than unsecured loans Tax-deductible interest in some jurisdictions Longer repayment terms available Leveraged ETFs and ETNs\nBuilt-in leverage without borrowing No margin calls Daily rebalancing may cause tracking error Available in various leverage ratios (2x, 3x) Options Strategies\nLEAPS (Long-term Equity AnticiPation Securities) Deep-in-the-money calls Synthetic long positions Requires options knowledge and monitoring Futures Contracts\nHigh leverage potential Standardized contracts Lower transaction costs Requires futures market expertise Portfolio Loans\nAvailable through some brokers and banks Can use multiple asset types as collateral Flexible terms and usage May offer better rates than traditional loans Box Spreads Financing\nAdvanced options strategy for borrowing Often provides very competitive rates Requires options approval level Limited to certain account types Key Considerations When Choosing a Method:\nInterest rates and borrowing costs Flexibility needs Risk tolerance Tax implications Market conditions Personal expertise level Account requirements Maintenance and monitoring needs Each method has unique advantages and risks. It\u0026rsquo;s often beneficial to:\nStart with simpler methods Understand all associated costs Have a clear risk management plan Consider using multiple methods to diversify risk Regular review and rebalancing as needed Conclusions Our analysis demonstrates that modest leverage (1.25x) in ETF investing can be an effective tool for enhancing portfolio returns when implemented thoughtfully. Key takeaways include:\nPerformance Enhancement\nThe 1.25x leveraged portfolio achieved significantly higher total returns (463.81% vs 344.20%) Annual returns improved by 17.8% while maintaining similar risk-adjusted metrics The benefits of leverage were consistent across different market conditions Risk Management\nModerate leverage resulted in proportional increase in volatility Risk metrics remained manageable with 1.25x leverage The Sharpe and Sortino ratios stayed nearly unchanged, indicating efficient risk-adjusted returns Implementation Strategy\nMultiple leverage methods are available, each with distinct advantages The choice of leverage method should align with individual circumstances Regular monitoring and rebalancing are essential Starting with conservative leverage ratios is recommended Best Practices\nMaintain adequate risk controls Diversify leverage sources when possible Keep borrowing costs low Have a clear exit strategy Regular portfolio review and rebalancing While leverage can amplify returns, it requires careful consideration, proper risk management, and ongoing monitoring. For investors willing to accept additional complexity and risk, modest leverage can be a valuable tool in portfolio management.\nAppendix A.1 Code for backtracking Leveraged Portfolio 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 import yfinance as yf import pandas as pd import numpy as np from datetime import datetime, timedelta import matplotlib.pyplot as plt from scipy import stats def fetch_data(tickers, start_date, end_date): \u0026#34;\u0026#34;\u0026#34;Fetch historical data for given tickers\u0026#34;\u0026#34;\u0026#34; data = pd.DataFrame() for ticker in tickers: df = yf.download(ticker, start=start_date, end=end_date)[\u0026#39;Adj Close\u0026#39;] data[ticker] = df return data def calculate_portfolio_returns(data, weights): \u0026#34;\u0026#34;\u0026#34;Calculate portfolio returns based on given weights\u0026#34;\u0026#34;\u0026#34; # Calculate daily returns returns = data.pct_change() # Calculate portfolio returns portfolio_returns = (returns * weights).sum(axis=1) return portfolio_returns def calculate_leveraged_returns(returns, leverage=1.25, borrowing_cost_annual=0.03): \u0026#34;\u0026#34;\u0026#34;Calculate leveraged returns with borrowing costs\u0026#34;\u0026#34;\u0026#34; # Convert annual borrowing cost to daily daily_borrowing_cost = (1 + borrowing_cost_annual) ** (1/252) - 1 # Calculate leveraged returns with borrowing cost leveraged_returns = returns * leverage - (leverage - 1) * daily_borrowing_cost return leveraged_returns def calculate_metrics(returns, risk_free_rate=0.03): \u0026#34;\u0026#34;\u0026#34;Calculate various performance metrics\u0026#34;\u0026#34;\u0026#34; metrics = {} # Convert to numpy array and remove NaN returns_clean = returns.dropna() # Basic metrics metrics[\u0026#39;Total Return\u0026#39;] = (1 + returns_clean).prod() - 1 metrics[\u0026#39;Annual Return\u0026#39;] = (1 + returns_clean).prod() ** (252/len(returns_clean)) - 1 metrics[\u0026#39;Daily Volatility\u0026#39;] = returns_clean.std() metrics[\u0026#39;Annual Volatility\u0026#39;] = returns_clean.std() * np.sqrt(252) # Sharpe Ratio excess_returns = returns_clean - risk_free_rate/252 metrics[\u0026#39;Sharpe Ratio\u0026#39;] = np.sqrt(252) * excess_returns.mean() / returns_clean.std() # Sortino Ratio downside_returns = returns_clean[returns_clean \u0026lt; 0] downside_std = downside_returns.std() metrics[\u0026#39;Sortino Ratio\u0026#39;] = np.sqrt(252) * excess_returns.mean() / downside_std # Maximum Drawdown cum_returns = (1 + returns_clean).cumprod() rolling_max = cum_returns.expanding().max() drawdowns = cum_returns/rolling_max - 1 metrics[\u0026#39;Maximum Drawdown\u0026#39;] = drawdowns.min() # Calmar Ratio metrics[\u0026#39;Calmar Ratio\u0026#39;] = metrics[\u0026#39;Annual Return\u0026#39;] / abs(metrics[\u0026#39;Maximum Drawdown\u0026#39;]) # Value at Risk (VaR) - 95% confidence metrics[\u0026#39;VaR 95%\u0026#39;] = np.percentile(returns_clean, 5) # Conditional VaR (CVaR/Expected Shortfall) metrics[\u0026#39;CVaR 95%\u0026#39;] = returns_clean[returns_clean \u0026lt;= metrics[\u0026#39;VaR 95%\u0026#39;]].mean() # Beta (using S\u0026amp;P 500 as market proxy) sp500 = yf.download(\u0026#39;^GSPC\u0026#39;, start=returns_clean.index[0], end=returns_clean.index[-1])[\u0026#39;Adj Close\u0026#39;].pct_change() # Align dates between portfolio returns and market returns aligned_data = pd.concat([returns_clean, sp500], axis=1).dropna() slope, _, r_value, _, _ = stats.linregress(aligned_data.iloc[:, 1], aligned_data.iloc[:, 0]) metrics[\u0026#39;Beta\u0026#39;] = slope metrics[\u0026#39;R-squared\u0026#39;] = r_value ** 2 # Information Ratio tracking_error = (returns_clean - aligned_data.iloc[:, 1]).std() * np.sqrt(252) metrics[\u0026#39;Information Ratio\u0026#39;] = (metrics[\u0026#39;Annual Return\u0026#39;] - 0.03) / tracking_error # Kurtosis and Skewness metrics[\u0026#39;Kurtosis\u0026#39;] = returns_clean.kurtosis() metrics[\u0026#39;Skewness\u0026#39;] = returns_clean.skew() return metrics def plot_portfolio_performance(returns): \u0026#34;\u0026#34;\u0026#34;Plot cumulative returns and drawdown\u0026#34;\u0026#34;\u0026#34; cumulative_returns = (1 + returns).cumprod() plt.figure(figsize=(12, 8)) # Plot cumulative returns plt.subplot(2, 1, 1) plt.plot(cumulative_returns.index, cumulative_returns.values) plt.title(\u0026#39;Cumulative Portfolio Returns\u0026#39;) plt.grid(True) # Plot drawdown plt.subplot(2, 1, 2) rolling_max = cumulative_returns.expanding().max() drawdowns = cumulative_returns/rolling_max - 1 plt.plot(drawdowns.index, drawdowns.values) plt.title(\u0026#39;Portfolio Drawdown\u0026#39;) plt.grid(True) plt.tight_layout() plt.savefig(\u0026#39;portfolio_performance.png\u0026#39;) plt.close() def main(): # Set parameters tickers = [\u0026#39;VOO\u0026#39;, \u0026#39;QQQ\u0026#39;] weights = [0.5, 0.5] start_date = \u0026#39;2015-01-01\u0026#39; end_date = datetime.now().strftime(\u0026#39;%Y-%m-%d\u0026#39;) # Fetch data print(\u0026#34;Fetching data...\u0026#34;) data = fetch_data(tickers, start_date, end_date) # Calculate portfolio returns print(\u0026#34;\\nCalculating portfolio returns...\u0026#34;) portfolio_returns = calculate_portfolio_returns(data, weights) # Calculate leveraged portfolio returns leveraged_returns = calculate_leveraged_returns(portfolio_returns) # Calculate metrics for both portfolios print(\u0026#34;\\nCalculating performance metrics...\u0026#34;) metrics_base = calculate_metrics(portfolio_returns) metrics_leveraged = calculate_metrics(leveraged_returns) # Print metrics comparison print(\u0026#34;\\nPortfolio Performance Metrics Comparison:\u0026#34;) print(\u0026#34;-\u0026#34; * 70) print(f\u0026#34;{\u0026#39;Metric\u0026#39;:\u0026lt;25} {\u0026#39;Base Portfolio\u0026#39;:\u0026gt;20} {\u0026#39;1.25x Leveraged\u0026#39;:\u0026gt;20}\u0026#34;) print(\u0026#34;-\u0026#34; * 70) for metric in metrics_base.keys(): base_value = metrics_base[metric] lev_value = metrics_leveraged[metric] print(f\u0026#34;{metric:\u0026lt;25} {base_value:\u0026gt;20.4f} {lev_value:\u0026gt;20.4f}\u0026#34;) # Plot performance comparison print(\u0026#34;\\nGenerating performance plots...\u0026#34;) plt.figure(figsize=(12, 8)) # Plot cumulative returns comparison plt.subplot(2, 1, 1) cum_returns_base = (1 + portfolio_returns).cumprod() cum_returns_lev = (1 + leveraged_returns).cumprod() plt.plot(cum_returns_base.index, cum_returns_base.values, label=\u0026#39;Base Portfolio\u0026#39;) plt.plot(cum_returns_lev.index, cum_returns_lev.values, label=\u0026#39;1.25x Leveraged\u0026#39;) plt.title(\u0026#39;Cumulative Portfolio Returns Comparison\u0026#39;) plt.grid(True) plt.legend() # Plot drawdown comparison plt.subplot(2, 1, 2) rolling_max_base = cum_returns_base.expanding().max() rolling_max_lev = cum_returns_lev.expanding().max() drawdowns_base = cum_returns_base/rolling_max_base - 1 drawdowns_lev = cum_returns_lev/rolling_max_lev - 1 plt.plot(drawdowns_base.index, drawdowns_base.values, label=\u0026#39;Base Portfolio\u0026#39;) plt.plot(drawdowns_lev.index, drawdowns_lev.values, label=\u0026#39;1.25x Leveraged\u0026#39;) plt.title(\u0026#39;Portfolio Drawdown Comparison\u0026#39;) plt.grid(True) plt.legend() plt.tight_layout() plt.savefig(\u0026#39;portfolio_performance_comparison.png\u0026#39;) plt.close() if __name__ == \u0026#34;__main__\u0026#34;: main() ","date":"2025-01-31T09:46:50+08:00","permalink":"https://light.ryankert.cc/p/leverage-in-etfs-investment/","title":"Leverage in Etfs Investment"},{"content":"Today I was solving Leetcode 2641. Cousins in Binary Tree II, a medium level problem.\nThe problem is about finding the cousins of a node in a binary tree. The cousins of a node are the nodes that are at the same level as the node but have different parents.\nThe first solution that came to my mind was a 2-pass DFS solution, which is O(n) in time complexity. Pretty fast right?\nWell, I got a TLE.\nI calculate the time each dfs function took:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 vector\u0026lt;int\u0026gt; levels; TreeNode* replaceValueInTree(TreeNode* root) { // Measure dfsadd time auto start_dfsadd = std::chrono::high_resolution_clock::now(); dfsadd(root, 0); auto end_dfsadd = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; elapsed_dfsadd = end_dfsadd - start_dfsadd; std::cout \u0026lt;\u0026lt; \u0026#34;dfsadd call took: \u0026#34; \u0026lt;\u0026lt; elapsed_dfsadd.count() \u0026lt;\u0026lt; \u0026#34; ms\\n\u0026#34;; // Measure dfs time auto start_dfs = std::chrono::high_resolution_clock::now(); dfs(root, 0, 0); auto end_dfs = std::chrono::high_resolution_clock::now(); std::chrono::duration\u0026lt;double, std::milli\u0026gt; elapsed_dfs = end_dfs - start_dfs; std::cout \u0026lt;\u0026lt; \u0026#34;dfs call took: \u0026#34; \u0026lt;\u0026lt; elapsed_dfs.count() \u0026lt;\u0026lt; \u0026#34; ms\\n\u0026#34;; return root; } void dfs(TreeNode* root, int level, int sibling) { if (!root) return; int sibr = 0, sibl = 0; if (root-\u0026gt;right) sibr = root-\u0026gt;right-\u0026gt;val; if (root-\u0026gt;left) sibl = root-\u0026gt;left-\u0026gt;val; dfs(root-\u0026gt;left, level+1, sibr); dfs(root-\u0026gt;right, level+1, sibl); root-\u0026gt;val = levels[level] - root-\u0026gt;val - sibling; } void dfsadd(TreeNode* root, int level) { if (!root) return; if (levels.size() \u0026lt; level+1) levels.push_back(0); levels[level] += root-\u0026gt;val; dfsadd(root-\u0026gt;left, level+1); dfsadd(root-\u0026gt;right, level+1); } And get:\n1 2 dfsadd call took: 1252.54 ms dfs call took: 2.32722 ms Running some profiling, I found out that the TLE is due to the push_back operation in C++. We often overlook its cost, but it is actually O(n) in the worst case, while we expect it to be O(logn) in average.\nInitialize a vector in the first place\n1 + levels.assign(1e5+1, 0); and delete the push_back operation(don\u0026rsquo;t try to save memory in this case) solve the problem.\n1 2 - if (levels.size() \u0026lt; level+1) - levels.push_back(0); Now it runs blazingly fast with only 4ms.\nThat is why we should absolutely care about the time complexity of each operation in our code. More importantly, we should be aware that some operations that we deem to be O(logn) might not be. It varies from each scenario.\n","date":"2024-10-23T12:00:51+08:00","permalink":"https://light.ryankert.cc/p/unexpected-tle-on-leetcode-2641.-cousins-in-binary-tree-ii/","title":"Unexpected TLE on Leetcode 2641. Cousins in Binary Tree II"},{"content":"目的和功能 YuniKorn 中的預佔機制允許高優先級任務通過預佔低優先級任務來動態重新分配資源，確保關鍵工作負載獲得必要的資源。這種主動機制維持系統穩定性和公平性，並與 Kubernetes 的優先級類別和 YuniKorn 的層級佇列系統整合。\n預佔類型(Preemption type) YuniKorn 提供兩種預佔類型：\n通用預佔：基於層級佇列模型，允許 Pod 選擇不運行。 DaemonSet 預佔：確保必須在特定節點上運行的 Pod 能夠運行。 主要特點 延遲觸發：預佔在指定延遲後觸發，可通過preemption.delay屬性配置。 層級佇列模型：預佔確保每個佇列的資源使用達到至少保證的資源量。 預佔法則：YuniKorn 實施七條預佔法則，以防止預佔風暴或循環。（下面會說明） 配置 佇列配置：可以在佇列級別使用preemption.policy和preemption.delay等屬性配置預佔。\nPod 級別配置：Pod 可以使用yunikorn.apache.org/allow-preemption註釋選擇不被預佔。\n優先級類別：YuniKorn 與 Kubernetes 的 PriorityClasses 整合以進行預佔。\n預佔法則(Preemption Rules) YuniKorn 遵循七條預佔法則，以確保公平和高效的資源分配：\n預佔策略是強烈建議，而非保證。 預佔不能使佇列低於其保證容量。 任務不能預佔同一應用程序中的其他任務。 只有當佇列低於保證容量時，任務才會觸發預佔。 只有當佇列超過保證容量時，任務才會被預佔。 任務只能預佔優先級較低或相等的任務。 任務不能預佔其預佔圍欄之外的任務。 預佔圍欄(Preemption fencing) YuniKorn 引入了預佔圍欄(Preemption fencing)的概念，允許將預佔範圍限制在某些佇列中。這確保特定佇列（及其子佇列）的優先級在內部評估，防止在多租戶環境中進行跨租戶預佔。\n通過實施這些預佔功能，YuniKorn 為複雜的 Kubernetes 環境提供了靈活而強大的調度解決方案，實現了跨各種工作負載和租戶的高效資源分配和優先級排序。\n","date":"2024-09-17T11:42:24+08:00","permalink":"https://light.ryankert.cc/p/apache-yunikorn-%E7%9A%84-preemption-%E6%A9%9F%E5%88%B6/","title":"Apache Yunikorn 的 Preemption 機制"},{"content":"Basics Registers Pseudo Instructions li is used to load an immediate value into a register. la is used to load an address into a register. (also can load a label address) mv is used to move a value from one register to another. (inclusive of addresses) ret is used to return from a function using the ra register. Print the prompt and read an integer 1 2 3 4 5 6 7 8 9 10 11 # Print the prompt la a0, prompt # Load address of the prompt into a0 li a7, 4 # System call for printing string ecall # Execute the call # Read an integer li a7, 5 # System call for reading an integer ecall # Execute the call, integer is now in a0 # Store the integer in another register, e.g., t0 mv t0, a0 # Move the integer from a0 to t0 Branch will not store return address(ra) blt, bge, bltu, bgeu, etc. will not also set the ra register. If you want to use the return address, you need to save it before the branch instruction. or use labels and jal instruction.\neg. the following code is a function demostrates 1 times a2 to a3 + 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 times_a2_to_a3_plus_1: li a0, 1 times_a2_to_a3_plus_1_loop: beq a2, a3, times_a2_to_a3_plus_1_end div t4, t5, a2 bge a0, t4, raise_int_max_exceeded mul a0, a0, a2 addi a2, a2, -1 j times_a2_to_a3_plus_1_loop times_a2_to_a3_plus_1_end: jr ra # or `ret` alternatively raise_int_max_exceeded: la a0, strRaisedIntMaxExceeded li a7, 4 ecall jr t3 in line 6, where I invoke the raise_int_max_exceeded function, I save the return address in t3 register. and in the raise_int_max_exceeded function, I use jr t3 to return to the caller.\nDifference between jal, jalr, j, jr jal and jalr is used to jump to a label and save the return address in ra register. jalr is used to jump to a register and save the return address in ra register. j is used to jump to a label. jr is used to jump to a register. Use stack to save registers eg.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 validate_input: addi sp, sp, -4 sw ra, 0(sp) # assert M \u0026gt; 0 blez s1, raised_not_natural # assert N \u0026gt;= 0 blt s2, zero, raised_less_than_zero # assert M \u0026gt;= N blt s1, s2, raised_M_smaller_than_N lw ra, 0(sp) addi sp, sp, 4 ret for more info, visit this blog post: RISC-V: Use Stack to Store Return Address\n","date":"2024-03-27T20:45:51+08:00","permalink":"https://light.ryankert.cc/p/risc-v-tips-and-tricks/","title":"RISC V: Tips and Tricks"},{"content":"Intro In RISC-V, the return address is stored in the ra register. However, in some cases, you may want to use the stack to store the return address. This can be useful when you need to save the return address before calling a function and restore it after the function returns.\nBest Practice To use the stack to store the return address in RISC-V, you can follow these steps:\nPush the return address onto the stack before calling the function. Call the function. Pop the return address from the stack after the function returns. Here is an example of how to use the stack to store the return address in RISC-V:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .section .text .global _start _start: # Push the return address onto the stack addi sp, sp, -4 sw ra, 0(sp) # Call the function jal function # Pop the return address from the stack lw ra, 0(sp) addi sp, sp, 4 # Exit the program li a7, 93 li a0, 0 ecall function: # Function body ret ","date":"2024-03-27T17:56:44+08:00","permalink":"https://light.ryankert.cc/p/risc-v-use-stack-to-store-return-address/","title":"RISC-V: Use Stack to Store Return Address"},{"content":"The Script Overview The script provided allows for easy creation and deletion of blog posts with Hugo, a popular static site generator. By passing different flags and the title of your blog post as arguments, you can quickly manage your content without directly interacting with the file system or Hugo commands.\nUsage To use this script, you would typically invoke it from the command line with the appropriate flags and arguments. For example, to create a post titled \u0026ldquo;My First Blog Post,\u0026rdquo; you would run:\n1 ./post.sh -c blog-post And to delete a post with the same title, you would use:\n1 ./post.sh -d blog-post The Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/usr/bin/env bash # while test $# -gt 0; do case \u0026#34;$1\u0026#34; in -h|--help) echo \u0026#34;Usage: $package [options] application [arguments]\u0026#34; echo \u0026#34; \u0026#34; echo \u0026#34;Options:\u0026#34; echo \u0026#34;-h, --help Show brief help\u0026#34; echo \u0026#34;-c, --create Create a new post\u0026#34; echo \u0026#34;-d, --delete Delete an existing post\u0026#34; exit 0 ;; -c|--create) shift if [[ -n $1 ]]; then echo \u0026#34;creating post $1...\u0026#34; hugo new content/post/$1/index.md echo \u0026#34;post $1 created.\u0026#34; else echo \u0026#34;no post name specified\u0026#34; exit 1 fi shift ;; -d|--delete) shift if [[ -n $1 ]]; then rm -r content/post/$1 echo \u0026#34;post $1 deleted.\u0026#34; else echo \u0026#34;no post directory specified\u0026#34; exit 1 fi shift ;; *) break ;; esac done file header #!/usr/bin/env bash The script starts with a shebang line #!/usr/bin/env bash that specifies the interpreter to use for executing the script. This line is essential for running the script as an executable file. (happy running in zsh)\nUnderstanding while test $# -gt 0; The script begins with a while loop that continues as long as there are arguments passed to the script ($# is greater than 0). $# is a special parameter in shell scripts that represents the number of arguments passed to the script. This loop allows the script to process multiple arguments sequentially, making it versatile and robust for different use cases.\nshift and Argument Processing Within the loop, we use the shift command to shift the arguments passed to the script. This command moves the positional parameters ($1, $2, etc.) to the left, effectively removing the first argument. This is crucial for processing different flags and arguments in the script.\nHow case Works Inside the while loop, we encounter a case statement. This statement is used for pattern matching. It takes the first argument passed to the script ($1), compares it against several patterns (-h, --help, -c, --create, -d, --delete), and executes the corresponding block of code based on the match.\nHelp (-h, --help): Displays usage information and exits. This is crucial for any script, providing users with guidance on how to use the tool. Create (-c, --create): Shifts to the next argument (the title of the post) and uses Hugo\u0026rsquo;s new command to create a new post. If no title is provided, it exits with an error. Delete (-d, --delete): Similar to create, but instead deletes the specified post directory using rm -r. The Conditional if [[ -n $1 ]]; then Within both the create and delete blocks, there\u0026rsquo;s a conditional statement if [[ -n $1 ]]; then that checks if the first argument (after shifting, which would be the title of the post or the post directory) is non-empty. -n $1 returns true if $1 has a non-zero length. This check ensures that the script doesn\u0026rsquo;t attempt to create or delete a post without a specified title or directory, which could lead to errors or unintended behavior.\n","date":"2024-03-27T12:22:20+08:00","permalink":"https://light.ryankert.cc/p/write-a-shell-script-to-automate-create-and-delete-post-on-hugo/","title":"Write a Shell Script to Automate Create and Delete Post on Hugo"},{"content":"Intro Frontmatter in Hugo is a block of YAML, TOML, or JSON at the beginning of a content file that contains metadata about the content. By default, Hugo provides a default frontmatter template for new content files. However, you can create a custom frontmatter file in Hugo by defining a custom archetype file.\nIn this tutorial, you will learn how to create a custom frontmatter file in Hugo.\nMethod Create a new archetype file ./archetypes/default.md in your Hugo project. Define the custom frontmatter template in the archetype file. Example 1 2 3 4 5 6 7 8 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; description: date: {{ .Date }} image: hidden: false comments: true --- ","date":"2024-03-27T11:42:24+08:00","permalink":"https://light.ryankert.cc/p/create-custom-frontmatter-file-in-hugo/","title":"Create Custom Frontmatter File in Hugo"},{"content":"Intro One of the easiest way to connect your Github account with your git installed on Mac or Windows is through Github Desktop. But, we can\u0026rsquo;t use that on wsl, so we use PAT(personal access token) to resolve this issue!\nSteps to setup on Windows 11 install git on Windows install Github Desktop Login your Github Desktop with your Github account install git on Mac/WSL 2/ Linux Install git(if not already installed) Mac: brew install git Linux/WSL2(debian): sudo apt-get install git check git version with 1 git --version setup git global config 1 2 git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; install Github CLI download and install Github CLI following this tutorial. In Ubuntu, you can install it with apt.\nlogin in the Github website\n1 gh auth login test: clone, commit and try to push a github repo 1 2 3 4 git clone \u0026lt;repo url\u0026gt; git add * git commit -am \u0026#34;commit name\u0026#34; git push output example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ git add * $ git commit -am \u0026#34;init\u0026#34; [master 563c3a8] init 1 file changed, 3 insertions(+), 16 deletions(-) $ git push Enumerating objects: 11, done. Counting objects: 100% (11/11), done. Delta compression using up to 20 threads Compressing objects: 100% (6/6), done. Writing objects: 100% (6/6), 608 bytes | 101.00 KiB/s, done. Total 6 (delta 5), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (5/5), completed with 5 local objects. To https://github.com/ryankert01/blog.git af6a1b1..563c3a8 master -\u0026gt; master Sign your commit with GPG key Generate a GPG Key:\nOpen a terminal and generate a new GPG key pair:\n1 gpg --full-generate-key Follow the prompts to create your key. Choose the following options when prompted:\nSelect kind of key: (1) RSA and RSA (default) Key size: 4096 Key expiration: 0 (never expires) List Your GPG Keys:\nAfter generating your key, you can list your keys to get the key ID:\n1 gpg --list-secret-keys --keyid-format LONG Look for the sec section and you can get the long key ID at the second line.\nCopy Your GPG Key:\nUse the long key ID to copy your GPG key:\n1 gpg --armor --export \u0026lt;your-long-key-id\u0026gt; \u0026gt; my-gpg-key.asc add GPG key to Github account\nUse the File Path with GitHub CLI:\nNow, you can use the file path with GitHub CLI:\n1 gh gpg-key add my-gpg-key.asc Yes, you can use GitHub CLI (gh) to simplify the process of adding your GPG key to GitHub. Here are the steps to do so:\nConfigure Git to Sign Your Commits:\nConfigure Git to use your GPG key for signing commits:\n1 2 git config --global user.signingkey \u0026lt;your-long-key-id\u0026gt; git config --global commit.gpgSign true Make and Sign a Commit:\nMake a new commit and push it to GitHub. The commit should be signed automatically if you enabled commit signing by default:\n1 2 git commit -m \u0026#34;Your commit message\u0026#34; git push To manually sign a commit, use the -S flag:\n1 git commit -S -m \u0026#34;Your commit message\u0026#34; These steps leverage GitHub CLI to streamline the process of adding your GPG key to GitHub and configuring Git to sign your commits.\nReference Git GPG Setup for macOS\n","date":"2024-03-13T12:01:11+08:00","image":"https://light.ryankert.cc/p/setup-github-and-get-your-commit-signed-with-git-and-github-cli/image_hu_ccb9ef2678b765fd.png","permalink":"https://light.ryankert.cc/p/setup-github-and-get-your-commit-signed-with-git-and-github-cli/","title":"Setup Github and get your commit signed With Git and Github CLI"},{"content":"Prompt for generative AI model 1 1 2 3 4 5 6 7 8 9 10 11 12 你是一名資工系的學生，而你剛聽完一場演講，需要寫一份觀後心得。 觀後心得的內容需要包含以下幾個部分： 1. 演講內容筆記 2. 對於演講內容的看法 3. 關於演講內容的延伸想法 以下是關於這場演講的大鋼，請根據大綱，使用繁體中文撰寫觀後心得，內容至少需要 700 字。 演講主題： 簡介： [大綱] Prompt for generative AI model 2 1 2 3 請將下列文章改寫成比較不像生成式 ai 生成的文句，加入更多生活中常用單字，更加口語，必須是段落式，不能進行列點： [result from generative ai model 1] post processing 將演講者改成老師。\n","date":"2024-03-09T00:23:55+08:00","permalink":"https://light.ryankert.cc/p/generative-ai-on-writing-presentation-notes-essays/","title":"Generative Ai on Writing Presentation Notes Essays"}]